<!doctype html>
<html lang="es">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Arcanoid Técnico + Power-Ups</title>
  <style>
    html,
    body {
      margin: 0;
      background: #0b1224;
      height: 100%;
      display: grid;
      place-items: center;
      font-family: system-ui, Segoe UI, Roboto, Arial
    }

    #wrap {
      position: relative
    }

    canvas {
      background: linear-gradient(180deg, #0f172a, #0b1224);
      border-radius: 14px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, .45)
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      background: rgba(0, 0, 0, .55);
      color: #fff;
      text-align: center;
      border-radius: 14px;
      padding: 20px
    }

    .overlay h2 {
      margin: 0 0 8px 0
    }

    .btn {
      margin-top: 10px;
      padding: 10px 14px;
      border-radius: 10px;
      background: #22c55e;
      color: #00111b;
      font-weight: 700;
      cursor: pointer;
      border: 0
    }

    .hud {
      position: absolute;
      left: 12px;
      top: 10px;
      color: #cbd5e1;
      font-size: 14px;
      user-select: none
    }

    .badges {
      position: absolute;
      right: 12px;
      top: 10px;
      color: #cbd5e1;
      font-size: 12px;
      text-align: right
    }
  </style>
</head>

<body>
  <div id="wrap">
    <canvas id="c" width="720" height="480"></canvas>
    <div class="hud">Puntos: <span id="score">0</span> · Vidas: <span id="lives">3</span></div>
    <div class="badges" id="badges"></div>
    <div class="overlay" id="ov">
      <h2 id="ovTitle">¡Game Over!</h2>
      <p id="ovMsg">Presioná ESPACIO o hacé clic para reiniciar</p>
      <button class="btn" id="restart">Reiniciar</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const badgesEl = document.getElementById('badges');
    const ov = document.getElementById('ov');
    const ovTitle = document.getElementById('ovTitle');
    const restartBtn = document.getElementById('restart');

    // ===== Config =====
    const W = canvas.width, H = canvas.height;
    const PADDLE = { w: 100, h: 12, x: (W - 100) / 2, y: H - 30, speed: 8, baseW: 100 };
    const BALL = { r: 7, x: W / 2, y: H / 2, vx: 4, vy: -4, speedUp: 1.03, maxSpeed: 12 };

    const ROWS = 6, COLS = 12;
    const BRICK = { w: (W - 60) / COLS, h: 20, gap: 5, top: 60, left: 30 };
    const COLORS = [...Array(ROWS)].map((_, r) => {
      const hue = 30 + r * 38;
      return `hsl(${hue} 80% 60%)`;
    });

    // ===== Power-ups =====
    const DROP_RATE = 0.22; // probabilidad de soltar algo al romper
    // tipos: vida extra, paleta XL, bola lenta
    const PU_TYPES = {
      LIFE: { id: 'life', label: '+1 vida', emoji: '💚', dur: 0 },
      PXL: { id: 'paddle', label: 'Paleta XL', emoji: '⬛', dur: 8000 },
      SLOW: { id: 'slow', label: 'Bola lenta', emoji: '🐌', dur: 6000 },
    };
    let powerups = [];
    let effects = []; // {id, until}

    let bricks = [];
    let score = 0;
    let lives = 3;
    let running = false;
    let gameEnded = false;

    // ===== Input =====
    const keys = {};
    window.addEventListener('keydown', e => {
      keys[e.key.toLowerCase()] = true;
      if (gameEnded && (e.key === ' ' || e.key === 'Enter')) reset();
    });
    window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
    canvas.addEventListener('mousemove', e => {
      const r = canvas.getBoundingClientRect();
      const x = e.clientX - r.left;
      PADDLE.x = Math.min(W - PADDLE.w, Math.max(0, x - PADDLE.w / 2));
    });
    canvas.addEventListener('click', () => { if (gameEnded) reset(); });
    restartBtn.addEventListener('click', reset);

    // ===== Util =====
    function newBricks() {
      bricks = [];
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          bricks.push({
            x: BRICK.left + c * (BRICK.w + BRICK.gap),
            y: BRICK.top + r * (BRICK.h + BRICK.gap),
            w: BRICK.w, h: BRICK.h,
            alive: true,
            color: COLORS[r]
          });
        }
      }
    }
    function resetBall() {
      BALL.x = W / 2; BALL.y = H - 60;
      const dir = Math.random() < .5 ? -1 : 1;
      BALL.vx = 4 * dir; BALL.vy = -4;
    }
    function reset() {
      score = 0; lives = 3; scoreEl.textContent = score; livesEl.textContent = lives;
      newBricks(); resetBall();
      powerups = []; effects = []; PADDLE.w = PADDLE.baseW;
      running = true; gameEnded = false; ov.style.display = 'none';
      PADDLE.x = (W - PADDLE.w) / 2;
      renderBadges();
    }

    // ===== Colisiones =====
    function collideRectCircle(rx, ry, rw, rh, cx, cy, cr) {
      const testX = Math.max(rx, Math.min(cx, rx + rw));
      const testY = Math.max(ry, Math.min(cy, ry + rh));
      const dx = cx - testX, dy = cy - testY;
      return dx * dx + dy * dy <= cr * cr;
    }

    // ===== Power-ups lógica =====
    function maybeDropPowerup(bx, by) {
      if (Math.random() > DROP_RATE) return;
      // elegir tipo al azar ponderado
      const pool = [PU_TYPES.LIFE, PU_TYPES.PXL, PU_TYPES.SLOW];
      const t = pool[(Math.random() * pool.length) | 0];
      powerups.push({
        x: bx + BRICK.w / 2 - 10,
        y: by + BRICK.h / 2 - 10,
        w: 20, h: 20,
        vy: 2.6,
        type: t
      });
    }

    function applyPowerup(pu) {
      const now = performance.now();
      switch (pu.type.id) {
        case 'life':
          lives++; livesEl.textContent = lives;
          break;
        case 'paddle':
          PADDLE.w = Math.min(PADDLE.baseW * 1.6, PADDLE.w * 1.3);
          effects = effects.filter(e => e.id !== 'paddle');
          effects.push({ id: 'paddle', until: now + PU_TYPES.PXL.dur });
          break;
        case 'slow':
          // escalar velocidades actuales y programar retorno
          BALL.vx *= 0.7; BALL.vy *= 0.7;
          effects = effects.filter(e => e.id !== 'slow');
          effects.push({ id: 'slow', until: now + PU_TYPES.SLOW.dur });
          break;
      }
      renderBadges();
    }

    function updateEffects() {
      const now = performance.now();
      const before = effects.length;
      effects = effects.filter(e => e.until > now);
      if (before !== effects.length) {
        // expiró algo: normalizar
        const hasPaddle = effects.some(e => e.id === 'paddle');
        if (!hasPaddle) PADDLE.w = PADDLE.baseW;

        const hasSlow = effects.some(e => e.id === 'slow');
        if (!hasSlow) {
          // volver a una velocidad razonable si quedó muy lenta
          const fix = 1 / 0.7;
          BALL.vx = Math.sign(BALL.vx) * Math.min(Math.abs(BALL.vx * fix), BALL.maxSpeed);
          BALL.vy = Math.sign(BALL.vy) * Math.min(Math.abs(BALL.vy * fix), BALL.maxSpeed);
        }
        renderBadges();
      }
    }

    function renderBadges() {
      if (!effects.length) { badgesEl.textContent = ''; return; }
      const lines = effects.map(e => {
        const t = e.id === 'paddle' ? PU_TYPES.PXL : PU_TYPES.SLOW;
        const sec = Math.max(0, Math.ceil((e.until - performance.now()) / 1000));
        return `${t.emoji} ${t.label} · ${sec}s`;
      });
      badgesEl.innerHTML = lines.join('<br>');
    }

    // ===== Update =====
    function update() {
      if (!running) return;

      updateEffects();

      // Paddle por teclado
      if (keys['arrowleft'] || keys['a']) PADDLE.x -= PADDLE.speed;
      if (keys['arrowright'] || keys['d']) PADDLE.x += PADDLE.speed;
      PADDLE.x = Math.max(0, Math.min(W - PADDLE.w, PADDLE.x));

      // Mover bola
      BALL.x += BALL.vx; BALL.y += BALL.vy;

      // Rebotar paredes
      if (BALL.x < BALL.r && BALL.vx < 0) { BALL.x = BALL.r; BALL.vx *= -1; }
      if (BALL.x > W - BALL.r && BALL.vx > 0) { BALL.x = W - BALL.r; BALL.vx *= -1; }
      if (BALL.y < BALL.r && BALL.vy < 0) { BALL.y = BALL.r; BALL.vy *= -1; }

      // Perder vida
      if (BALL.y > H + 20) {
        lives--; livesEl.textContent = lives;
        if (lives <= 0) return end(false);
        resetBall();
      }

      // Colisión con paddle
      if (collideRectCircle(PADDLE.x, PADDLE.y, PADDLE.w, PADDLE.h, BALL.x, BALL.y, BALL.r)) {
        BALL.vy = -Math.abs(BALL.vy);
        const hit = (BALL.x - (PADDLE.x + PADDLE.w / 2)) / (PADDLE.w / 2); // -1..1
        BALL.vx = Math.max(-BALL.maxSpeed, Math.min(BALL.maxSpeed, BALL.vx + hit * 2));
        BALL.vx *= BALL.speedUp; BALL.vy *= BALL.speedUp;
        BALL.vx = Math.sign(BALL.vx) * Math.min(Math.abs(BALL.vx), BALL.maxSpeed);
        BALL.vy = Math.sign(BALL.vy) * Math.min(Math.abs(BALL.vy), BALL.maxSpeed);
      }

      // Colisión con ladrillos
      for (const b of bricks) {
        if (!b.alive) continue;
        if (collideRectCircle(b.x, b.y, b.w, b.h, BALL.x, BALL.y, BALL.r)) {
          b.alive = false; score += 10; scoreEl.textContent = score;

          // Drop de power-up
          maybeDropPowerup(b.x, b.y);

          // rebotar por eje
          const prevX = BALL.x - BALL.vx, prevY = BALL.y - BALL.vy;
          const hitX = prevX < b.x || prevX > b.x + b.w;
          const hitY = prevY < b.y || prevY > b.y + b.h;
          if (hitX) BALL.vx *= -1;
          if (hitY) BALL.vy *= -1;
          break;
        }
      }

      // Victoria si no quedan ladrillos
      if (bricks.every(b => !b.alive)) end(true);

      // Actualizar y chequear power-ups que caen
      for (let i = powerups.length - 1; i >= 0; i--) {
        const p = powerups[i];
        p.y += p.vy;
        // atrapado por la paleta
        const catchX = p.x < PADDLE.x + PADDLE.w && p.x + p.w > PADDLE.x;
        const catchY = p.y + p.h >= PADDLE.y && p.y <= PADDLE.y + PADDLE.h;
        if (catchX && catchY) {
          applyPowerup(p);
          powerups.splice(i, 1);
          continue;
        }
        // fuera de pantalla
        if (p.y > H + 40) powerups.splice(i, 1);
      }
    }

    function end(win) {
      running = false; gameEnded = true;
      ovTitle.textContent = win ? '¡Ganaste! 🎉' : '¡Game Over!';
      ov.style.display = 'flex';
    }

    // ===== Draw =====
    function draw() {
      ctx.clearRect(0, 0, W, H);

      // Paddle
      ctx.fillStyle = '#22c55e';
      ctx.fillRect(PADDLE.x, PADDLE.y, PADDLE.w, PADDLE.h);

      // Bola
      ctx.beginPath();
      ctx.arc(BALL.x, BALL.y, BALL.r, 0, Math.PI * 2);
      ctx.closePath();
      ctx.fillStyle = '#e2e8f0';
      ctx.shadowColor = 'rgba(255,255,255,.4)';
      ctx.shadowBlur = 8;
      ctx.fill();
      ctx.shadowBlur = 0;

      // Ladrillos
      for (const b of bricks) {
        if (!b.alive) continue;
        ctx.fillStyle = b.color;
        ctx.fillRect(b.x, b.y, b.w, b.h);
        ctx.fillStyle = 'rgba(255,255,255,.15)';
        ctx.fillRect(b.x, b.y, b.w, b.h / 4);
      }

      // Power-ups
      for (const p of powerups) {
        ctx.fillStyle = 'rgba(255,255,255,.2)';
        ctx.fillRect(p.x, p.y, p.w, p.h);
        ctx.fillStyle = '#fff';
        ctx.font = '14px system-ui';
        const icon = p.type.emoji;
        ctx.fillText(icon, p.x + 3, p.y + 15);
      }
    }

    function loop() { update(); draw(); requestAnimationFrame(loop); }
    reset(); loop();
  </script>
</body>

</html>