<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>Snake Mejorado üêç</title>
  <style>
    :root {
      --bg: #111;
      --panel: #222;
      --accent: #0f0;
      --text: #fff;
      --muted: #ccc;
    }

    html,
    body {
      height: 100%;
    }

    body {
      background-color: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      text-align: center;
      margin: 0;
      padding: 30px 12px 24px;
      display: grid;
      place-items: start center;
      gap: 10px;
    }

    a.btn-back {
      color: #9ff;
      text-decoration: none;
    }

    h1 {
      margin: 6px 0 10px;
    }

    canvas {
      background-color: var(--panel);
      border: 2px solid var(--accent);
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }

    #score,
    #level,
    #bestScore {
      font-size: 20px;
      margin: 5px;
      display: inline-block;
    }

    .sep {
      opacity: .4;
      margin: 0 6px;
    }

    button {
      margin: 12px;
      padding: 10px 20px;
      font-size: 18px;
      cursor: pointer;
      background-color: var(--accent);
      border: none;
      color: #000;
      border-radius: 8px;
      transition: transform .05s ease;
    }

    button:active {
      transform: translateY(1px);
    }

    #message {
      font-size: 16px;
      color: var(--muted);
      margin-top: 6px;
      min-height: 22px;
    }

    /* Botonera de flechas */
    #snake-controls {
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      display: grid;
      grid-template-rows: auto auto;
      gap: 8px;
      z-index: 9999;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
    }

    #snake-controls .middle-row {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }

    #snake-controls button {
      width: 72px;
      height: 72px;
      font-size: 28px;
      line-height: 1;
      border: none;
      border-radius: 14px;
      background: #1f2937;
      color: #fff;
      box-shadow: 0 6px 16px rgba(0, 0, 0, .25), inset 0 -4px 0 rgba(255, 255, 255, .05);
      cursor: pointer;
    }

    #snake-controls button:active {
      transform: translateY(1px) scale(0.98);
      filter: brightness(1.08);
    }

    /* En escritorio grande, ocultar botonera */
    @media (min-width: 900px) {
      #snake-controls {
        display: none;
      }
    }

    /* Mobile: escalar canvas y reservar espacio para la botonera */
    @media (max-width: 480px) {
      canvas {
        width: 92vw;
        height: 92vw;
        max-width: 420px;
        max-height: 420px;
      }

      #score,
      #level,
      #bestScore {
        font-size: 18px;
      }

      button {
        font-size: 18px;
        padding: 12px 18px;
      }

      /* margen para que la botonera no tape el canvas */
      .game-wrap {
        margin-bottom: 120px;
      }
    }
  </style>
</head>

<body>
  <a href="index.html" class="btn-back">‚¨Ö Volver al men√∫</a>
  <h1>üêç Snake</h1>

  <div class="game-wrap">
    <!-- Canvas cuadrado (400x400 l√≥gicos). En m√≥vil se escala v√≠a CSS -->
    <canvas id="game" width="400" height="400" aria-label="Juego Snake"></canvas>

    <div>
      <span id="score">Puntos: 0</span><span class="sep">|</span>
      <span id="level">Nivel: 1</span><span class="sep">|</span>
      <span id="bestScore">Mejor Puntaje: 0</span>
    </div>

    <button id="restartBtn">Reiniciar Juego</button>
    <div id="message">Desliz√° el dedo, us√° flechas o la botonera para empezar‚Ä¶</div>
  </div>

  <!-- Botonera Snake -->
  <div id="snake-controls" aria-label="Controles de direcci√≥n">
    <button data-dir="up" aria-label="Arriba">‚ñ≤</button>
    <div class="middle-row">
      <button data-dir="left" aria-label="Izquierda">‚óÄ</button>
      <button data-dir="down" aria-label="Abajo">‚ñº</button>
      <button data-dir="right" aria-label="Derecha">‚ñ∂</button>
    </div>
  </div>

  <script>
    /* ====== Setup b√°sico ====== */
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const scoreEl = document.getElementById("score");
    const levelEl = document.getElementById("level");
    const bestScoreEl = document.getElementById("bestScore");
    const restartBtn = document.getElementById("restartBtn");
    const message = document.getElementById("message");
    const controls = document.getElementById("snake-controls");

    const gridSize = 20;                       // tama√±o de celda (px)
    const tileCount = canvas.width / gridSize; // 400/20 = 20

    let snake, direction, food, score, level, speed, gameInterval, started = false;
    let bestScore = Number(localStorage.getItem('bestScore') || 0);
    bestScoreEl.textContent = "Mejor Puntaje: " + bestScore;

    /* ====== Audio ====== */
    let AC = window.AudioContext || window.webkitAudioContext;
    let audioCtx = null;
    function unlockAudio() {
      if (audioCtx) return;
      try {
        audioCtx = new AC();
        const b = audioCtx.createBuffer(1, 1, 22050);
        const s = audioCtx.createBufferSource();
        s.buffer = b; s.connect(audioCtx.destination); s.start(0);
      } catch (e) { }
    }
    function beep() {
      if (!audioCtx) return;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'square'; o.frequency.value = 600; g.gain.value = 0.05;
      o.connect(g); g.connect(audioCtx.destination);
      o.start(); setTimeout(() => { o.stop(); o.disconnect(); g.disconnect(); }, 100);
    }

    /* ====== L√≥gica principal ====== */
    function initGame() {
      snake = [{ x: 10, y: 10 }];
      direction = { x: 0, y: 0 };
      placeFood();
      score = 0; level = 1; speed = 200; started = false;
      scoreEl.textContent = "Puntos: " + score;
      levelEl.textContent = "Nivel: " + level;
      message.textContent = "Desliz√° el dedo, us√° flechas o la botonera para empezar‚Ä¶";
      clearInterval(gameInterval);
      drawGame();
    }

    function placeFood() {
      let valid = false;
      while (!valid) {
        food = {
          x: Math.floor(Math.random() * tileCount),
          y: Math.floor(Math.random() * tileCount)
        };
        valid = !snake.some(seg => seg.x === food.x && seg.y === food.y);
      }
    }

    function startGameLoop() {
      clearInterval(gameInterval);
      gameInterval = setInterval(gameLoop, speed);
    }

    function gameLoop() {
      const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

      // Choques
      if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount ||
        snake.some(seg => seg.x === head.x && seg.y === head.y)) {
        endGame(); return;
      }

      snake.unshift(head);

      // Comer
      if (head.x === food.x && head.y === food.y) {
        score++; beep();
        scoreEl.textContent = "Puntos: " + score;
        if (score % 5 === 0) {
          level++; levelEl.textContent = "Nivel: " + level;
          speed = Math.max(50, speed - 20);
          startGameLoop(); // aplicar nueva velocidad
        }
        placeFood();
      } else {
        snake.pop();
      }

      drawGame();
    }

    function drawGame() {
      ctx.fillStyle = "#222"; ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "red";
      ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize, gridSize);
      snake.forEach((seg, idx) => {
        ctx.fillStyle = idx === 0 ? "#00ff00" : "#0f0";
        ctx.fillRect(seg.x * gridSize, seg.y * gridSize, gridSize - 1, gridSize - 1);
      });
    }

    function endGame() {
      clearInterval(gameInterval);
      if (score > bestScore) {
        bestScore = score;
        localStorage.setItem('bestScore', String(bestScore));
        bestScoreEl.textContent = "Mejor Puntaje: " + bestScore;
      }
      message.textContent = "¬°Perdiste! Puntaje final: " + score + ". Toc√° Reiniciar para jugar de nuevo.";
      started = false;
    }

    /* ====== Teclado (PC) ====== */
    document.addEventListener("keydown", e => {
      if (!started && ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
        started = true; message.textContent = ""; unlockAudio();
        switch (e.key) {
          case "ArrowUp": direction = { x: 0, y: -1 }; break;
          case "ArrowDown": direction = { x: 0, y: 1 }; break;
          case "ArrowLeft": direction = { x: -1, y: 0 }; break;
          case "ArrowRight": direction = { x: 1, y: 0 }; break;
        }
        startGameLoop(); return;
      }
      switch (e.key) {
        case "ArrowUp": if (direction.y === 0) direction = { x: 0, y: -1 }; break;
        case "ArrowDown": if (direction.y === 0) direction = { x: 0, y: 1 }; break;
        case "ArrowLeft": if (direction.x === 0) direction = { x: -1, y: 0 }; break;
        case "ArrowRight": if (direction.x === 0) direction = { x: 1, y: 0 }; break;
      }
    });

    /* ====== Swipe t√°ctil ====== */
    let touchStart = null;
    function pointerDown(e) {
      unlockAudio();
      const r = canvas.getBoundingClientRect();
      touchStart = { x: e.clientX - r.left, y: e.clientY - r.top, t: Date.now() };
      if (!started) {
        started = true; message.textContent = "";
        const midX = canvas.width / 2, midY = canvas.height / 2;
        const dx = (e.clientX - r.left) - midX;
        const dy = (e.clientY - r.top) - midY;
        if (Math.abs(dx) > Math.abs(dy)) direction = { x: dx > 0 ? 1 : -1, y: 0 };
        else direction = { x: 0, y: dy > 0 ? 1 : -1 };
        startGameLoop();
      }
    }
    function pointerUp(e) {
      if (!touchStart) return;
      const r = canvas.getBoundingClientRect();
      const dx = (e.clientX - r.left) - touchStart.x;
      const dy = (e.clientY - r.top) - touchStart.y;
      touchStart = null;
      const absX = Math.abs(dx), absY = Math.abs(dy);
      if (absX < 12 && absY < 12) return;
      if (absX > absY) {
        if (dx > 0 && direction.x === 0) direction = { x: 1, y: 0 };
        if (dx < 0 && direction.x === 0) direction = { x: -1, y: 0 };
      } else {
        if (dy > 0 && direction.y === 0) direction = { x: 0, y: 1 };
        if (dy < 0 && direction.y === 0) direction = { x: 0, y: -1 };
      }
    }
    canvas.addEventListener('pointerdown', pointerDown, { passive: false });
    canvas.addEventListener('pointerup', pointerUp, { passive: false });
    canvas.addEventListener('touchmove', e => e.preventDefault(), { passive: false });

    /* ====== Botonera: flechas ====== */
    function pressDir(dir) {
      unlockAudio();
      // arrancar si a√∫n no inici√≥
      if (!started) { started = true; message.textContent = ""; startGameLoop(); }
      if (dir === 'up' && direction.y === 0) direction = { x: 0, y: -1 };
      if (dir === 'down' && direction.y === 0) direction = { x: 0, y: 1 };
      if (dir === 'left' && direction.x === 0) direction = { x: -1, y: 0 };
      if (dir === 'right' && direction.x === 0) direction = { x: 1, y: 0 };
      if (navigator.vibrate) navigator.vibrate(10);
    }
    if (controls) {
      ['touchstart', 'touchmove', 'touchend', 'pointerdown'].forEach(t => {
        controls.addEventListener(t, ev => ev.preventDefault(), { passive: false });
      });
      controls.addEventListener('pointerdown', e => {
        const btn = e.target.closest('button[data-dir]');
        if (!btn) return;
        pressDir(btn.dataset.dir);
      });
      // (Opcional) auto-repetici√≥n si manten√©s apretado:
      /*
      let holdTimer = null, holdId = null, holdDir = null;
      controls.addEventListener('pointerdown', e => {
        const btn = e.target.closest('button[data-dir]'); if (!btn) return;
        pressDir(btn.dataset.dir);
        holdDir = btn.dataset.dir; holdId = e.pointerId;
        holdTimer = setInterval(() => pressDir(holdDir), 120);
      });
      function stopHold(e){ if(holdTimer) clearInterval(holdTimer); holdTimer=null; holdId=null; holdDir=null; }
      window.addEventListener('pointerup', stopHold);
      window.addEventListener('pointercancel', stopHold);
      */
    }

    /* ====== Bot√≥n Reiniciar ====== */
    restartBtn.addEventListener("click", initGame);

    /* ====== Init ====== */
    initGame();
  </script>
</body>

</html>