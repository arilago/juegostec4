<!doctype html>
<html lang="es">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <title>Arcanoid Técnico + Power-Ups</title>

  <style>
    html,
    body {
      margin: 0;
      background: #0b1224;
      height: 100%;
      display: grid;
      place-items: center;
      font-family: system-ui, Segoe UI, Roboto, Arial;
    }

    #wrap {
      position: relative;
    }

    canvas {
      background: linear-gradient(180deg, #0f172a, #0b1224);
      border-radius: 14px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, .45);
      touch-action: none;
      /* ✅ clave para móvil */
    }

    /* ✅ Responsive para celulares */
    @media (max-width: 800px) {
      #wrap {
        width: 92vw;
      }

      canvas {
        width: 92vw;
        height: calc(92vw * 480/720);
      }
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      background: rgba(0, 0, 0, .55);
      color: #fff;
      text-align: center;
      border-radius: 14px;
      padding: 20px;
    }

    .overlay h2 {
      margin: 0 0 8px 0;
    }

    .btn {
      margin-top: 10px;
      padding: 10px 14px;
      border-radius: 10px;
      background: #22c55e;
      color: #00111b;
      font-weight: 700;
      cursor: pointer;
      border: 0;
    }

    .hud {
      position: absolute;
      left: 12px;
      top: 10px;
      color: #cbd5e1;
      font-size: 14px;
      user-select: none;
    }

    .badges {
      position: absolute;
      right: 12px;
      top: 10px;
      color: #cbd5e1;
      font-size: 12px;
      text-align: right;
    }
  </style>
</head>

<body>
  <div id="wrap">
    <canvas id="c" width="720" height="480"></canvas>

    <div class="hud">Puntos: <span id="score">0</span> · Vidas: <span id="lives">3</span></div>
    <div class="badges" id="badges"></div>

    <div class="overlay" id="ov">
      <h2 id="ovTitle">¡Game Over!</h2>
      <p id="ovMsg">Tocá o apretá ESPACIO para reiniciar</p>
      <button class="btn" id="restart">Reiniciar</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const badgesEl = document.getElementById('badges');
    const ov = document.getElementById('ov');
    const ovTitle = document.getElementById('ovTitle');
    const restartBtn = document.getElementById('restart');

    // ===== Config =====
    const W = canvas.width, H = canvas.height;
    const PADDLE = { w: 100, h: 12, x: (W - 100) / 2, y: H - 30, speed: 8, baseW: 100 };
    const BALL = { r: 7, x: W / 2, y: H / 2, vx: 4, vy: -4, speedUp: 1.03, maxSpeed: 12 };

    const ROWS = 6, COLS = 12;
    const BRICK = { w: (W - 60) / COLS, h: 20, gap: 5, top: 60, left: 30 };
    const COLORS = [...Array(ROWS)].map((_, r) => {
      const hue = 30 + r * 38; return `hsl(${hue} 80% 60%)`;
    });

    // ===== Power-ups =====
    const DROP_RATE = 0.22;
    const PU_TYPES = {
      LIFE: { id: 'life', label: '+1 vida', emoji: '💚', dur: 0 },
      PXL: { id: 'paddle', label: 'Paleta XL', emoji: '⬛', dur: 8000 },
      SLOW: { id: 'slow', label: 'Bola lenta', emoji: '🐌', dur: 6000 }
    };
    let powerups = [], effects = [];
    let bricks = [];
    let score = 0, lives = 3;
    let running = false, gameEnded = false;

    // ===== Input =====
    const keys = {};
    window.addEventListener('keydown', e => {
      keys[e.key.toLowerCase()] = true;
      if (gameEnded && (e.key === ' ' || e.key === 'Enter')) reset();
    });
    window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

    // ✅ Conversión touch/mouse → coordenada de juego real
    function movePaddleClientX(clientX) {
      const r = canvas.getBoundingClientRect();
      const xGame = ((clientX - r.left) / r.width) * W;
      PADDLE.x = Math.min(W - PADDLE.w, Math.max(0, xGame - PADDLE.w / 2));
    }

    // ✅ Mouse
    canvas.addEventListener('mousemove', e => movePaddleClientX(e.clientX));

    // ✅ Touch (pointer events)
    canvas.addEventListener('pointerdown', e => {
      canvas.setPointerCapture?.(e.pointerId);
      movePaddleClientX(e.clientX);
      if (gameEnded) reset();
    });
    canvas.addEventListener('pointermove', e => movePaddleClientX(e.clientX));

    // ✅ Evitar scroll accidental
    canvas.addEventListener('touchmove', e => e.preventDefault(), { passive: false });

    canvas.addEventListener('click', () => { if (gameEnded) reset(); });
    restartBtn.addEventListener('click', reset);

    // ===== Utils =====
    function newBricks() {
      bricks = [];
      for (let r = 0; r < ROWS; r++)
        for (let c = 0; c < COLS; c++)
          bricks.push({
            x: BRICK.left + c * (BRICK.w + BRICK.gap),
            y: BRICK.top + r * (BRICK.h + BRICK.gap),
            w: BRICK.w, h: BRICK.h,
            alive: true,
            color: COLORS[r]
          });
    }
    function resetBall() {
      BALL.x = W / 2; BALL.y = H - 60;
      const dir = Math.random() < .5 ? -1 : 1;
      BALL.vx = 4 * dir; BALL.vy = -4;
    }
    function reset() {
      score = 0; lives = 3;
      scoreEl.textContent = score; livesEl.textContent = lives;
      newBricks(); resetBall();
      powerups = []; effects = []; PADDLE.w = PADDLE.baseW;
      running = true; gameEnded = false; ov.style.display = 'none';
      PADDLE.x = (W - PADDLE.w) / 2;
      renderBadges();
    }

    function collideRectCircle(rx, ry, rw, rh, cx, cy, cr) {
      const testX = Math.max(rx, Math.min(cx, rx + rw));
      const testY = Math.max(ry, Math.min(cy, ry + rh));
      const dx = cx - testX, dy = cy - testY;
      return dx * dx + dy * dy <= cr * cr;
    }

    // PowerUp drop
    function maybeDropPowerup(bx, by) {
      if (Math.random() > DROP_RATE) return;
      const pool = [PU_TYPES.LIFE, PU_TYPES.PXL, PU_TYPES.SLOW];
      const t = pool[(Math.random() * pool.length) | 0];
      powerups.push({ x: bx + BRICK.w / 2 - 10, y: by + BRICK.h / 2 - 10, w: 20, h: 20, vy: 2.6, type: t });
    }

    function applyPowerup(pu) {
      const now = performance.now();
      switch (pu.type.id) {
        case 'life': lives++; livesEl.textContent = lives; break;
        case 'paddle':
          PADDLE.w = Math.min(PADDLE.baseW * 1.6, PADDLE.w * 1.3);
          effects = effects.filter(e => e.id !== 'paddle');
          effects.push({ id: 'paddle', until: now + PU_TYPES.PXL.dur });
          break;
        case 'slow':
          BALL.vx *= 0.7; BALL.vy *= 0.7;
          effects = effects.filter(e => e.id !== 'slow');
          effects.push({ id: 'slow', until: now + PU_TYPES.SLOW.dur });
          break;
      }
      renderBadges();
    }

    function updateEffects() {
      const now = performance.now();
      const before = effects.length;
      effects = effects.filter(e => e.until > now);
      if (before !== effects.length) {
        if (!effects.some(e => e.id === 'paddle')) PADDLE.w = PADDLE.baseW;
        if (!effects.some(e => e.id === 'slow')) {
          const fix = 1 / 0.7;
          BALL.vx = Math.sign(BALL.vx) * Math.min(Math.abs(BALL.vx * fix), BALL.maxSpeed);
          BALL.vy = Math.sign(BALL.vy) * Math.min(Math.abs(BALL.vy * fix), BALL.maxSpeed);
        }
        renderBadges();
      }
    }
    function renderBadges() {
      if (!effects.length) { badgesEl.textContent = ''; return; }
      badgesEl.innerHTML = effects.map(e => {
        const t = (e.id === 'paddle') ? PU_TYPES.PXL : PU_TYPES.SLOW;
        const sec = Math.max(0, Math.ceil((e.until - performance.now()) / 1000));
        return `${t.emoji} ${t.label} · ${sec}s`;
      }).join('<br>');
    }

    // ===== Update =====
    function update() {
      if (!running) return;

      updateEffects();

      if (keys['arrowleft'] || keys['a']) PADDLE.x -= PADDLE.speed;
      if (keys['arrowright'] || keys['d']) PADDLE.x += PADDLE.speed;
      PADDLE.x = Math.max(0, Math.min(W - PADDLE.w, PADDLE.x));

      BALL.x += BALL.vx; BALL.y += BALL.vy;

      if (BALL.x < BALL.r || BALL.x > W - BALL.r) BALL.vx *= -1;
      if (BALL.y < BALL.r) BALL.vy *= -1;

      if (BALL.y > H + 20) {
        lives--; livesEl.textContent = lives;
        if (lives <= 0) return end(false);
        resetBall();
      }

      if (collideRectCircle(PADDLE.x, PADDLE.y, PADDLE.w, PADDLE.h, BALL.x, BALL.y, BALL.r)) {
        BALL.vy = -Math.abs(BALL.vy);
        const hit = (BALL.x - (PADDLE.x + PADDLE.w / 2)) / (PADDLE.w / 2);
        BALL.vx = Math.max(-BALL.maxSpeed, Math.min(BALL.maxSpeed, BALL.vx + hit * 2));
      }

      for (const b of bricks) {
        if (!b.alive) continue;
        if (collideRectCircle(b.x, b.y, b.w, b.h, BALL.x, BALL.y, BALL.r)) {
          b.alive = false; score += 10; scoreEl.textContent = score;
          maybeDropPowerup(b.x, b.y);
          BALL.vy *= -1;
          break;
        }
      }

      if (bricks.every(b => !b.alive)) end(true);

      for (let i = powerups.length - 1; i >= 0; i--) {
        const p = powerups[i];
        p.y += p.vy;
        if (p.y > H + 30) powerups.splice(i, 1);
        if (
          p.x < PADDLE.x + PADDLE.w && p.x + p.w > PADDLE.x &&
          p.y + p.h >= PADDLE.y && p.y <= PADDLE.y + PADDLE.h
        ) {
          applyPowerup(p);
          powerups.splice(i, 1);
        }
      }
    }

    function end(win) {
      running = false; gameEnded = true;
      ovTitle.textContent = win ? '¡Ganaste! 🎉' : '¡Game Over!';
      ov.style.display = 'flex';
    }

    // ===== Draw =====
    function draw() {
      ctx.clearRect(0, 0, W, H);

      ctx.fillStyle = '#22c55e';
      ctx.fillRect(PADDLE.x, PADDLE.y, PADDLE.w, PADDLE.h);

      ctx.beginPath();
      ctx.arc(BALL.x, BALL.y, BALL.r, 0, Math.PI * 2);
      ctx.fillStyle = '#e2e8f0'; ctx.fill();

      for (const b of bricks) {
        if (!b.alive) continue;
        ctx.fillStyle = b.color;
        ctx.fillRect(b.x, b.y, b.w, b.h);
      }

      for (const p of powerups) {
        ctx.fillStyle = 'rgba(255,255,255,.2)';
        ctx.fillRect(p.x, p.y, p.w, p.h);
        ctx.fillStyle = '#fff';
        ctx.font = '14px system-ui';
        ctx.fillText(p.type.emoji, p.x + 3, p.y + 15);
      }
    }

    function loop() { update(); draw(); requestAnimationFrame(loop); }

    // Start
    reset(); loop();
  </script>
</body>

</html>